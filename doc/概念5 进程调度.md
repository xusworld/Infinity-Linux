概念5 进程调度

[TOC]

### 1 基本概念

​		对于单处理器系统，同一时间只有一个进程可以运行，其他进程都应等待，直到CPU空闲并可调用为止。多到程序的**设计目标是始终允许某个进程运行以最大化CPU利用率**。一个进程从执行到它应该等待为止，通常等待吗某个I/O请求的完成。对于简单的计算机系统，CPU就会处于闲置状态，浪费了大量的CPU资源。采用多道程序就是试图利用这个时间。多个程序处于内存，当一个程序等待时，操作系统就会从该进程接管CPU控制，并将CPU交给另一个进程。这种方式不断重复，当一个进程等待时，另一个进程接管CPU使用权。

​		下面介绍一些进程调度中的核心概念。

#### 1.1 CPU调度程序

​		每当CPU空闲时，操作系统就应从就绪队列中选择一个进程来执行。进程选择采用**短期调度程序（short-term scheduler）或CPU调度程序**。调度程序从内存中选择一个能够执行的进程，并为其分配CPU。

​		注意，就绪队列不必是先进先出（FIFO）队列。正如在研究各种调度算法时将会看到的：就绪队列的实现可以是FIFO队列、优先队列、树或简单的无序链表。然而，在概念上，就绪队列的所有进程都要排队以便等待在CPU上执行。队列内的记录通常为进程控制块（Process Control Block, PCB）。

#### 1.2 抢占调度

​		需要进行CPU调度的情况可以分为四种：

- 当一个进程从运行状态切换到等待状态（例如 IO请求，或wait()调用以便等待一个子进程的终止）。

- 当一个进程从运行状态切换到就绪状态时（例如，当出现中断时）

- 当一个进程从等待状态切换到就绪状态时（例如，IO完成）

- 当一个进程终止时。

  对于第1种和第4种情况，除了调度没有选择。一个新进程（如果就绪队列有一个进程存在）必须被选择执行。不过对于第2种和第3种情况，还是有选择的。

  如果调度只能发生在第1种和第4种情况下，则调度方案成为**非抢占的（nonpreemptive）或 协作的（cooperative）**，否则，调度方案成为**抢占的（preemptive）**。在非抢占调度下，一旦某个进程分配到CPU，该进程就会一直使用CPU，直到它终止或切换到等待状态。

![part2-process-states](/Users/lukedong/Documents/OCS/images/part2-process-states.png)

#### 1.3 调度程序

​		与CPU调度功能有关的另一个组件是**调度程序（dispatcher）。**调度程序是一个模块，用来将CPU控制交给由短期调度程序选择的进程。这个功能包括：

- 切换上下文。
- 切换到用户模式。
- 跳转到用户程序合适的位置，以便重新启动程序。

调度程序应尽可能加快，因为每次进程切换的时候都要使用。调度程序停止一个进程而启动另一个进程所需的时间称为 **调度延迟（dispatch latency）。**

### 2 调度准则（调度算法的评价标准）

​		为了比较CPU调度算法，可以采用许多准则作为评价标准。

- CPU使用率：应使CPU尽可能忙碌。从概念上讲，CPU使用率从0%到100%，对于一个实际的系统，它的范围应该是从 40%的轻负荷系统 到 90%的重负荷系统。
- **吞吐量（throughput）：**一个时间单元内进程完成的数量。对于长进程，吞吐量可能为每小时一个进程，对于短进程，吞吐量可能为每秒十个进程。
- **周转时间（turnaround time）：**从进程提交到进程完成的时间称为周转时间。从一个特定进程的角度来看，一个CPU调度算法的评价标准是运行这个进程需要多长时间。周转时间是所有时间段之和，<u>包括等待进入内存、在就绪队列中等待、在CPU上执行和I/O执行。</u>
- **等待时间：**CPU调度算法不会影响进程运行和I/O执行时间，调度算法只会影响进程在就绪队列中因等待所需的时间。等待时间为进程在就绪队列中等待所用时间之和。
- **响应时间：**从提交请求到产生第一响应的时间称为响应时间。响应时间对于交互式系统尤为关键。

### 3 调度算法

​		CPU调度处理的问题是：从就绪队列中选择进程以便为其分配CPU。

#### 3.1 先来先服务算法

​		**先来先服务（First-Come First-Serverd, FCFS）**算法是最简单的CPU调度算法。此处我还为大家配置了精美的插图来解释先来先服务算法（虽然没有必要 :low_brightness: ）



![part2-scheduling-fcfs](/Users/lukedong/Documents/OCS/images/part2-scheduling-fcfs.jpg)

​		<u>FCFS算法是非抢占的，一旦CPU分配给了一个进程，该进程就会使用CPU直到释放CPU为止</u>，即进程终止或等待IO。FCFS对于分时系统（每个用户需要定时得到一定的CPU时间）是特别麻烦的，允许一个进程使用CPU过长将是一个严重的错误。

#### 3.2 最短作业优先调度

​		**最短作业优先调度（Shortest-Job-First， SJF）**算法，这个算法将每个进程与其下次CPU执行的长度关联起来。当CPU变空闲时，它会被赋予具有最短CPU执行的进程。

> 读到这句话，你至少能想到SJF算法两个不科学的地方，一是每次选择最短CPU执行时间的进程，那么可怜的长进程该怎么办？二是怎么能提前得知CPU的执行时间？

​	![part2-scheduling-sjf0](/Users/lukedong/Documents/OCS/images/part2-scheduling-sjf0.png)

![part2-scheduling-sjf1](/Users/lukedong/Documents/OCS/images/part2-scheduling-sjf1.png)

理论上来说，SJF调度算法是最优的。<u>因为给定一组进程，SJF算法的平均等待时间最小。</u>通过将短进程移到长进程之前，短进程的等待时间减少大于长进程等待时间的增加，因而平均等待时间会减少。

​		SJF算法的真正困难是如何知道下次CPU执行长度。对于批处理系统的长期调度，可以将用户提交作业时指定的进程时限作为长度。这种情况下，用户有意精确估计进程时间，这是因为低值可能意味着更快的响应。SJF调度算法常用于长期调度。

​		虽然SJF算法是最优的，但是它不能在短期CPU调度级别上加以实现，因为没有办法知道CPU执行的长度。

#### 3.3 优先级调度

​		**优先级调度（priority-scheduling）**中每个进程都指定了一个优先级，具有最高优先级的进程会分配到CPU，具有相同优先级的进程将会按照FCFS顺序调度。

![part2-scheduling-ps0](/Users/lukedong/Documents/OCS/images/part2-scheduling-ps0.jpg)

##### 3.3.1 定义优先级

​		优先级的定义可以是内部的也可以是外部的。内部定义的优先级采用一些测量数据计算进程优先级，如时限、内存要求、打开文件数量和平均IO执行时间或平均CPU执行之比等，都可以用于计算优先级。外部定义的优先级采用操作系统之外的准则，比如进程的重要性、用于支付使用计算机的费用类型和部门、赞助部门等。

##### 3.3.2 评价

​		**优先级调度算法可以是抢占的或非抢占的。**当一个进程到达就绪队列时，比较它的优先级与当前运行进程的优先级。如果新到达的进程的优先级高于当前运行进程的优先级，那么抢占优先级调度算法就会抢占CPU。非抢占优先级调度算法只是将新的进程加到就绪队列的头部。

​		优先级调度算法的主要问题是**无穷阻塞（indefinite blocking）或饥饿（starvation）**，就绪运行但是等待CPU的进程可以认为是阻塞的。优先级调度算法可以让某个低优先级的进程无穷等待CPU。在1973年关闭MIT的IBM 7094时，发现有一个低优先级进程早在1967年就已提交，但是一直未能运行。

​		**无穷阻塞**问题的一个解决方案就是**老化（aging）**，老化逐渐增加在系统中等待很长时间进程的优先级。

:thumbsup:抢占/非抢占均可、老化

:thumbsdown:无穷阻塞/饥饿

#### 3.4 轮转调度

​		**轮转（Round-Robin， RR）**算法是专门为分时系统设计的。它类似于FCFS调度，但是增加了抢占以切换进程。将一个较小时间单元定义为**时间量（time quantum）**或**时间片（time slice）**。时间片的大小通常是 10 ～ 100ms。就绪队列作为循环队列，CPU调度程序循环整个队列，为每个进程分配不超过一个时间片的CPU。

​		为了实现RR调度，我们再次将就绪队列视为进程的FIFO队列。新进程添加到就绪队列的尾部。<u>CPU调度程序从就绪队列中选择第一个进程，将定时器设置在一个时间片后中断，最后分派这个进程。</u>

![part2-scheduling-rr0](/Users/lukedong/Documents/OCS/images/part2-scheduling-rr0.png)

​	轮转调度时，进程可能只需少于时间片的CPU执行时间，对于这种情况，进程本身会自动释放CPU，轮转调度算法接着处理就绪队列的下一个进程。否则，如果当前进程的CPU执行大于一个时间片，那么定时器会中断，进而中断操作系统。然后，进行上下文切换，再将进程驾到就绪队列的尾部，接着CPU调度程序会选择就绪队列内的下一个进程。

![part2-scheduling-rr1](/Users/lukedong/Documents/OCS/images/part2-scheduling-rr1.jpg)



##### 3.4.1 评价

:thumbsup:可抢占

:thumbsdown:性能受时间片大小影响

​		当一个进程的CPU执行超过一个时间片时，进程会被抢占，并放回到就绪队列中，因此轮转调度算法是可抢占算法。

​		RR算法的性能取决于时间片的大小。如果时间片很大，保证每个进程的CPU执行小于时间片大小，那么RR算法退化为FCFS算法；如果时间片很小，RR算法则会进行大量的上下文切换，严重影响性能。

#### 3.5 多级队列调度

​		在进程容易分成不同组的情况下，可以有另一类调度算法。例如，进程通常分为**前台进程（foreground process）（或交互进程）**和**后台进程（background process）（或批处理进程）**。这两种类型的进程具有不同的响应时间要求，进而也有不同的调度需要。另外，与后台进程相比，前台进程可能要有更高的优先级。

​		**多级队列（multilevel queue）**调度算法将就绪队列分成多个单独队列。根据进程属性，如内存大小、进程优先级、进程类型等，一个**进程永久分到一个队列**。每个队列有自己的调度算法，例如，前台队列可以采用RR算法调度，而后台队列可以采用FCFS算法调度。

![part2-scheduling-mq0](/Users/lukedong/Documents/OCS/images/part2-scheduling-mq0.png)

​		每个队列的进程与更低层队列相比具有绝对的优先。例如，只有系统进程、交互进程和交互编辑进程队列都为空，批处理列内的进程才可运行。<u>如果在一个批处理进程运行时有一个交互进程进入就绪队列，那么该批处理进程就会被抢占。</u>

#### 3.6 多级反馈队列调度

​		多级队列调度算法中，进程进入系统时被永久的分配到某个队列。例如，如果前台和后台进程分别具有单独队列，那么进程并不从一个队列移到另一个队列，这是因为进程不会改变前台或后台的性质。这种设置的优点是调度开销低，缺点是不够灵活。

​		**多级反馈队列（multilevel feedback queue）**调度算法允许进程在队列之间进行迁移。这种想法是，根据不同CPU执行的特点来区分进程，如果进程使用过多的CPU时间，那么它会被移到更低的优先级队列。这种方案将IO密集型和交互进程放在更高优先级上。此外，在较低优先级队列中等待过长的进程会被移到更高优先级队列。这种形式的老化阻止饥饿发生。

![part2-scheduling-mfq](/Users/lukedong/Documents/OCS/images/part2-scheduling-mfq.jpg)

​		现在有三个队列，调度程序首先执行队列0内所有进程，只有当队列0为空时，它才执行队列1内的进程，以此类推。此外，到达队列1的进程会抢占队列2的进程，队列0的进程会抢占队列1的进程。

​		多级反馈队列调度算法是最通用的CPU调度算法。通常情况下，它能适应所设定的系统，遗憾的是，由于需要一些方法来选择参数以定义最佳的调度程序，所以它也是最复杂的算法。



### 4 多处理器调度

​		目前主要讨论的是单处理器系统的CPU调度问题，如果有多个CPU，则负载分配（loading sharing）