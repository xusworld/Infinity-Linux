[TOC]

### 0 目标



### 1 死锁产生的必要条件

- **互斥(mutual exelusion)**: 至少有一个资源必须处于非共享模式，即一次只有一个进程可使用。如果另一进程申请该资源，那么申请进程应该等到该资源释放为止。

- **占有并等待(hold and wait)**: 一个进程应占有至少一个资源，并等待一个资源，而该资源为其他进程所有。

- **非抢占(no preemption)**: 资源不能被抢占，即资源只能被进程在完成任务后自愿释放。

- **循环等待(circular wait)**: 有一组等待进程，前一个进程等待的资源被后一个资源占有。

四个条件同时成立的时候，才会产生死锁。👍

### 2 死锁处理方法

通常来说，处理死锁问题一般有三种方法：

- 通过协议来预防或避免死锁，确保系统不会进入死锁状态。

- 可以允许系统进入死锁状态，然后检测它，并加以恢复。

- 可以忽视这个问题，认为死锁不会发生在系统中。

令人惊讶的是，第三种解决方案为大多数操作系统所采用，包括Linux和Windows。因此，开发者需要自己编程以解决死锁。

### 3 死锁预防方法

​	死锁的产生有四个必要条件，换个角度考虑，只需破坏四个条件中的一个即可预防死锁的发生。

#### 3.1 互斥

​	互斥条件必须成立，共享资源不要求互斥访问，进程便不会等待资源，不可能产生死锁。

#### 3.2 持有且等待

​	为了确保持有且等待条件不会出现在系统中，应保证：当每个进程申请一个资源时，它不能占有其他资源。一种可以采用的协议是，每个进程在执行前申请并获得所有资源，即要求进程申请资源的系统调用在所有其他系统调用之前进行。另一种协议允许进程在没有资源时才可申请资源，一个进程可申请一些资源并使用，然而，在进一步申请更多资源前，它应该释放现已分配的所有资源。

​	举例说明两种协议之间的差别，现有一个进程，进程将数据从DVD驱动器复制到磁盘文件，并对磁盘文件进行排序，再打印结果到打印机。如果所有资源在进程开始之前申请，那么进程应一开始就申请DVD驱动器、磁盘文件和打印机。在进程的整个执行过程中，会一直占有打印机，尽管它只在结束时才需要打印机。

​	第二种方法允许：进程在开始时只申请DVD驱动器和磁盘文件。它将数据从DVD到磁盘，再释放DVD驱动器和磁盘文件。然后，进程再申请磁盘文件和打印机。当复制数据从磁盘文件到打印机之间，它就释放这两个资源并终止。

​	这两种协议有两个主要缺点。第一，资源利用率可能比较低，因为许多申请的资源可能已经分配，但很长时间都没有被使用。例如，在所给的例子中，只有确认数据始终处于磁盘文件的情况下，才可以释放DVD驱动器和磁盘文件，并再次申请磁盘文件和打印机资源。否则，不管采用哪种协议，应在开始之前申请所有资源。第二，可能发生饥饿，一个进程如需要多种资源，可能必须永久等待，因为它所需要的资源中至少有一个已分配给其他进程。

#### 3.3 无抢占

​	第三个必要条件，不能抢占已分配的资源。为了确保这一条件不成立，可以采用如下协议：如果一个进程持有资源并申请另一个不能立即分配的资源（也就是说，这个进程应等待），那么进程现在分配的资源都可被抢占。换句话说，这些资源都隐式释放了。被抢占资源添加到进程等待的资源列表上，只有当进程获得其原有资源和申请的新资源时，进程才可以重新执行。

​	换句话说，如果一个进程申请一些资源，那么首先检查这些资源是否可用，如果可用，那么就分配，如果不可用，那么检查这些资源是否已经分配给等待额外资源的其他进程。如果是，那么从等待进程中抢占这些资源，并分配给申请进程。如果资源不可用且也不会被其他等待进程持有，那么申请进程应该等待。当一个进程处于等待时，如果其他进程申请其拥有资源，那么该进程的部分资源可以被抢占。只有当一个进程分配到申请的资源，并且恢复在等待时被抢占的资源时，它才可能重新执行。

​	这个协议通常用于状态可以保存和恢复的资源，如CPU寄存器和内存，它一般不适用于其他资源，如互斥锁和信号量。

#### 3.4 循环等待

​	死锁的第四个也是最后一个条件是循环等待。确保这个条件不成立的一个方法是：对所有资源类型进行完全排序，而且要求每个进程按递增顺序申请资源。

### 4 死锁避免

