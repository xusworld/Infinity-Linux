

[TOC]

### 1 进程

#### 1.1 进程概念

##### 1.1.1 进程解释

​		**进程**是执行中的程序，但进程不仅仅是程序代码，程序代码有时称为**文本段**（或**代码段**）。进程还包括当前活动，通过**程序计数器**的值和处理器寄存器的内容来表示。另外，进程通常还包括进程**堆栈段**（包括临时数据，如函数参数、返回地址和局部变量）和**数据段**（包括全局变量）。进程还可能包括**堆(heap)**，是进程在运行期间动态分配的内存。

​		程序本身不是进程：程序只是**被动实体**，如存储在磁盘上包含一系列指令的文件内容(常被成为可执行文件)，而进程是**活动实体**，它有一个程序计数器用来表示下一个要执行的命令和相关资源集合。**当一个可执行文件被转入内存时，一个程序才能成为进程。**

##### 1.1.2 进程状态

进程在执行时会改变状态。进程**状态**在某种程度上是由当前活动定义的。每个进程可能处于下列状态之一

* 新的：进程正在被创建
* 运行：指令正在被执行
* 等待：进程等待某个事件的发生(如I/O完成或收到信号)
* 就绪：进程等待分配处理器
* 终止：进程完成执行

![image-20200302165657647](/Users/lukedong/Documents/OCS/images/part2-process-states.png)

##### 1.1.3 进程控制块
每个进程在操作系统内用**进程控制块(process control block, PCB)** 来表示。

* 进程状态: 状态可包括新的、就绪、运行、等待、停止等。
* 程序计数器: 计数器表示进程要执行的下个指令的地址。
* CPU寄存器: 根据操作系统的不同，寄存器的数量和类型也不同。
* CPU调度信息: 这类信息包括进程优先级、调度队列的指针和其他调度参数。
* 内存管理信息: 根据操作系统所使用的内存系统，这类信息包括基址和界限寄存器的值、页表或段表。
* 记账信息: 这类信息包括CPU时间、实际使用时间、时间界限、记账数据、作业或者进程数量等。
* I/O状态信息：这类信息包括分配给进程的I/O设备列表、打开的文件列表等。

![part2-process-pcb](/Users/lukedong/Documents/OCS/images/part2-process-pcb.jpg)

#### 1.2 进程调度

​		多道程序的设计目的是无论何时都有进程在运行，从而使CPU利用率达到最大化。分时系统的目的是在进程之间快速切换CPU以便用户在程序运行时能够与其进行交互。为了达到此目的，**进程调度（process scheduler）**选择一个可用的进程（可能从多个可用进程集合中选择）到CPU上执行。单处理器系统从不会有超过一个进程在运行。如果有多个进程，那么余下的则需要等待CPU空闲并重新调度。

##### 1.2.1 调度队列

​		进程进入系统时，会被加到**作业队列**中，该队列包括系统中的所有进程。驻留在内存中就绪的、等待运行的进程保存在**就绪队列**中。该队列通常用链表来实现，其头节点指向链表的第一个和最后一个PCB块的指针。每个PCB包括一个指向就绪队列的下一个PCB的指针域。

##### 1.2.2 调度程序

​		进程在其生命周期中会在各种调度队列之间迁移。为了调度，操作系统必须按某种方式从这些队列中选择进程。进程选择是由相应的**调度程序（scheduler）**来执行的。

​		通常对于批处理系统，进程更多地是被提交，而不是马上执行。这些进程将被放到大容量存储设备(通常为磁盘)的缓冲池中，保存在那里以便以后执行。**长期调度程序（long-term scheduler）** 或 **作业调度程序( job scheduler)** 从该池中选择进程，并转入内存以准备执行。**短期调度程序(short-term scheduler)** 或**CPU调度程序** 从准备执行的进程中选择进程，并位置分配CPU。

​		这两个调度程序的主要差别是它们执行的频率。短期调度程序必须频繁地为CPU选择新进程。

![part2-process-device_queue](/Users/lukedong/Documents/OCS/images/part2-process-device_queue.png)

#### 1.3 进程运行

​		大多数操作系统（包括UNIX、Linux和Windows）对进程的识别采用的是唯一的进程标识符（process identifiler, pid），通常是一个整数值。系统内的每个进程都有一个唯一的pid，可以用作索引，以便访问内核中的进程的各种属性。

#### 1.4 进程间通信		

​		操作系统内的并发执行的进程可以是独立的也可以是协作的。如果一个进程不能影响其他进程或收到其他进程的影响，那么这个进程是**独立的**。显然，不与任何其他进程共享数据的进程是独立的。如果一个进程能影响其他进程或受其他进程所影响，那么该进程是协作的。显然，与其他进程共享数据的进程是协作进程。

提供环境允许进程协作，具有许多理由

- **信息共享**：由于多个用户可能对同样的信息感兴趣（例如共享文件），所以应提供环境以允许并发访问这些信息。

- **计算加速**：如果希望一个特定任务快速运行，那么应将它分成子任务，而每个子任务可以与其他子任务一起并行执行。注意，如果实现这样的加速，那么计算机需要有多个处理核。

- **模块化**：可能需按模块化方式构造系统，将系统功能分成独立的进程或线程。

- **方便**：即使单个用户也可能同时执行许多任务。例如，用户可以并行地编辑、收听音乐、编译。

:sos: **面试​必考问题** :sos:

协作进程需要有一种 **进程间通信(InterProcess Communication. IPC)** 机制，以允许进程互相交换数据与信息。进程间通信有两种基本模型：**共享内存(shared memory)** 和 **消息传递(message passing)** 。共享内存模型会建立起一块供协作进程共享的内存区域，进程通过向此共享区域读出或写入数据来交换信息。消息传递模型通过在协作进程间交换信息来实现通信。

##### 1.4.1 共享内存系统

​		采用共享内存的进程间通信，需要建立共享内存区域。通常，一片内存区域驻留在创建共享内存段的进程地址空间内。其它希望使用这个共享内存段进程通信的进程应将其附加到自己的地址空间。通常，操作系统会试图阻止一个进程访问另一个进程的内存，共享内存需要两个或更多的进程同意取消这一限制；这样它们通过在共享区域内读出或写入来交换信息。数据的类型或位置取决于这些进程，而不是受控于操作系统。另外，进程负责确保，它们不向同一位置同时写入数据。

​		通过共享内存系统进行进程间通信的范例可以视为一个生产者-消费者问题。生产者（producer）负责生成信息，以供消费者（consumer）消费。生产者-消费者问题同时还为客户机-服务机范例提供了有用的比喻。通常，将服务器作为生产者，客户机视为消费者。

​		解决生产者-消费者问题的方法之一，就是采用共享内存。为了允许生产者进程和消费者进程并发执行，应该有一个可用的缓冲区，以被生产者填充和被消费者清空。这个缓存区驻留在生产者进程和消费者进程的共享内存区域内。缓冲区的类型可以分为两种，无界缓冲区（unbounded-buffer）和有界缓冲区（bounded-buffer），无界缓冲区没有限制缓冲区的大小，消费者可能不得不等待新的项，但生产者总是可以产生新项，有界缓冲区假设固定大小的缓冲区，如果缓冲区为空，则消费者必须等待，如果缓冲区为满，则生产者必须等待。

![part2-process-device_queue](/Users/lukedong/Documents/OCS/images/part2-process-sm.png)

##### 1.4.2 消息传递系统

​		消息传递系统提供一种机制，以便允许进程不必通过共享地址空间来实现通信和同步。对分布式环境（通信进程可能位于通过网络连接的不同计算机上），消息传递系统极为有用。既然要进行通信，那么通信参与者需要具备两项能力

```
send(message)
receive(message)
```

​		通信的种类可以简单的分为直接通信和间接通信。

（1）直接通信

​		直接通信有两种方案，方案一的通信原语设计如下

```
方案一 对称寻址
send(P, message) # 向进程P发送message
receive(Q, message) # 从进程Q接收message
```

​		这种方法的通信链路具有以下属性：

- 在需要通信的每对进程之间，自动建立链路。进程仅需要知道对方身份就可以进行交流。
- 每个链路只与两个进程相关。
- 每对进程之间只有一个链路。

```
方案二 非对称寻址
send(P, message) # 向进程P发送message
receive(id, message) # 从任何进程，接收message，这里变量id被设置成与其通信进程的名称
```

​		这两种方案的缺点是：生成进程定义的有限模块化。更改进程的标识符可能需要分析所有其他进程定义。所有旧的标识符的引用都应找到，以便修改成新标识符。通常，任何这样的硬编码（hard-coding）技术（其中标识符需要明确指定），与下面所述的采用间接通信技术相比要差。

（2）间接通信

​		在间接通信（indirect communication）中，通过邮箱或端口来发送和接收消息。邮箱可以抽象成一个对象，进程可以向其中存放消息，也可以从中删除消息，每个邮箱都有一个唯一的标识符。一个进程可以通过多个不同的邮箱与另一个进程进行通信，但是两个进程只有拥有一个共享邮箱时才能通信。

```
通信原语定义

send(A, message) # 向进程A发送message
receive(A, message) # 从进程A接收message

该方案下，通信链路具有以下特点
- 只有在两个进程共享一个邮箱时，才能建立通信链路。
- 一个链路可以与两个或更多进程相关联。
- 两个通信进程之间可以有多个不同链路，每个链路对应一个邮箱。
```

##### 1.4.3 管道 :sos:

​		管道允许两个进程进行通信。管道是早起UNIX系统最早使用的一种进程间通信机制。管道为进程之间的相互通信提供了一种较为简单的方法，尽管也有一定的局限性。在实现管道时，应该考虑以下四个问题。

- 管道允许单向通信还是双向通信？
- 如果允许双向通信，它是半双工的（数据在同一时间内只能按一个方向传输）还是全双工的（数据在同一时间内可以在两个方向上传输）？
- 通信进程之间是否应有一定的关系？（如父子关系）
- 管道通信能够通过网络，还是只能在同一台机器上进行？



（1）普通管道

​		普通管道允许两个进程按标准的生产者 - 消费者方式进行通信：生产者向管道的一端（写入端）写，消费者从管道的另一端（读出端）读。因此，普通管道都是单向的，只允许单向通信。



（2）命名管道

​		命名管道提供了一个更强大的通信工具。通信可以是双向的，并且父子关系不是必须的。当建立了一个命名管道之后，多个进程都可以用它进行通信。事实上，在一个典型的场景中，一个命名管道有几个写者。此外，通信进程完成后，命名管道继续存在。

